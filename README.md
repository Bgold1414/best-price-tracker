# This is my video game wishlist application!

## Getting started with requesting my API key from Steam
The first step was to acquire my API key from Steam by going to their page and using my GitHub account via GitHub Pages to register for a key. This process was surprisingly smooth, and it set the foundation for everything else. Once I had the key, I created an environment inside Visual Studio Code (VSCode), setting it up with Flask and using the dotenv library to hold my Steam API key. With the help of chatgpt4-o, I ensured that my key was stored securely by adding it to the `.gitignore` file, preventing accidental exposure when pushing to GitHub.

After setting up my environment, I moved on to testing the "Fetch Game Prices" function to see if I could get a response for price comparison. This was the first proof of concept that validated my use of the API key. Essentially, it utilizes the Steam API key to fetch price data for any game based on its app ID. The function is designed to handle different scenarios: if the game is found, it returns the price; if the game is free to play, it indicates that; and if the game cannot be found, it returns an appropriate error message. The comparison function is an essential feature that takes a Steam app ID as input and returns a JSON response with the relevant price information. This step helped me realize the importance of graceful error handling when making API requests, as not all games have complete information.

## Second step setting up an HTML/CSS/Jinja logic for the front end
With the backend functional, I moved on to setting up a front end where users could interact with the website. I installed some basic HTML, CSS, and Jinja to create a simple but user-friendly interface. The HTML provided the structure, while CSS enhanced the user experience with styling, making the site more visually appealing and interactive. I used Jinja as a templating engine to add logic for checking whether a game existed based on its Steam app ID, connecting to the backend Flask app.

One of the challenges I faced here was ensuring that the front end interacted smoothly with the backend. For example, initially, my form submissions weren't working as expected—I was repeatedly getting a "method not allowed" error. After some troubleshooting, I realized that the issue lay in the form submission URL. The form was trying to submit data to `wishlist.html`, but it was supposed to be submitting to `update.html`. I corrected this mistake and then ensured that the logic connected properly between the HTML pages and the backend.

The more I worked on the front end, the more I realized that relying solely on the Steam API was not the most efficient way to handle data retrieval. For instance, every time a user searched for a game, the app would reach out to Steam's API, which was both time-consuming and prone to rate limiting. To solve this, I integrated SQLAlchemy to create a database for storing games. This allowed users to search for a game by name, and the app would first try to retrieve the game from the local database before querying the Steam API. This greatly increased the efficiency and responsiveness of the app. If the game wasn't in the local database, only then would it reach out to the Steam API for the information.

## Third step installing Flask SQLAlchemy
To manage data more effectively, I used `pip` to install Flask SQLAlchemy. I chose SQLAlchemy because it made handling relational data much more straightforward, and it integrated seamlessly with Flask. I also installed `Flask-Migrate` to facilitate database migrations. This way, if changes needed to be made to the data model, I wouldn't have to recreate the database from scratch—I could simply apply the necessary migrations.

After setting up SQLAlchemy, I defined a `Game` class that represented the structure of my games table, with fields for the game ID, name, Steam app ID, and price. I added debug flags in my code to notify me whether the table creation was successful or if there were any issues. Once the table was successfully created, I built out functionality for adding games. I added a function called `add_game()` that takes in a game name, its Steam app ID, and its price, and then adds it to the database.

Next, I created a `Wishlist` table that joined with the `Game` table. The goal was to allow users to not only search for games but also add them to their wishlist. Users could either add games directly from the Steam search results or add them manually from their wishlist interface. Connecting the `Game` and `Wishlist` tables proved to be very useful because it allowed me to use relationships within SQLAlchemy to easily query the database for wishlisted games along with their details.

One of the main challenges with setting up the database was getting everything to migrate correctly when changes were needed. Initially, I made changes to the game model but forgot to apply migrations, which led to some frustrating moments when the application wasn't working as expected. After a few attempts and some help from chatgpt4-o, I finally understood the importance of running the migration commands every time there were changes in the model.

To round off the development, I added functionality for users to view and manage their wishlist. The wishlist feature provided users with options to update game details, remove games, or compare prices directly from their list. I wanted this feature to be as user-friendly as possible, so I spent time making sure the forms were intuitive and that error messages were helpful.

Overall, this project has been a tremendous learning experience for me—from dealing with API keys and learning to secure sensitive information, to building a database-backed web application that is both efficient and user-friendly. Each step posed its own unique set of challenges, and overcoming them was incredibly rewarding. The integration of Flask, SQLAlchemy, and Steam's API allowed me to build a cohesive and interactive wishlist application that gamers can use to track the prices of their favorite games.


